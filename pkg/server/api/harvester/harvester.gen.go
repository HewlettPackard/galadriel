// Package harvester provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package harvester

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/HewlettPackard/galadriel/pkg/common/api"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Harvester_authScopes = "harvester_auth.Scopes"
)

// BundlePutRequest defines model for BundlePutRequest.
type BundlePutRequest struct {
	// Digest base64 encoded SHA-256 digest of the bundle
	Digest externalRef0.BundleDigest `json:"digest"`

	// Signature base64 encoded signature of the bundle
	Signature *externalRef0.Signature `json:"signature,omitempty"`

	// SigningCertificate X.509 certificate in PEM format
	SigningCertificate *externalRef0.Certificate `json:"signing_certificate,omitempty"`

	// TrustBundle SPIFFE Trust bundle in JSON format
	TrustBundle externalRef0.TrustBundle     `json:"trust_bundle"`
	TrustDomain externalRef0.TrustDomainName `json:"trust_domain"`
}

// BundleSyncPostRequest defines model for BundleSyncPostRequest.
type BundleSyncPostRequest struct {
	State BundlesDigests `json:"state"`
}

// BundleSyncPostResponse defines model for BundleSyncPostResponse.
type BundleSyncPostResponse struct {
	State   BundlesDigests          `json:"state"`
	Updates TrustBundleSyncResponse `json:"updates"`
}

// BundlesDigests defines model for BundlesDigests.
type BundlesDigests map[string]externalRef0.BundleDigest

// HarvesterOnboardResponse defines model for HarvesterOnboardResponse.
type HarvesterOnboardResponse struct {
	Token           externalRef0.JWT             `json:"token"`
	TrustDomainID   externalRef0.UUID            `json:"trustDomainID"`
	TrustDomainName externalRef0.TrustDomainName `json:"trustDomainName"`
}

// JwtGetResponse defines model for JwtGetResponse.
type JwtGetResponse struct {
	Token externalRef0.JWT `json:"token"`
}

// RelationshipGetResponse defines model for RelationshipGetResponse.
type RelationshipGetResponse = []externalRef0.Relationship

// RelationshipPatchRequest defines model for RelationshipPatchRequest.
type RelationshipPatchRequest struct {
	ConsentStatus externalRef0.ConsentStatus `json:"consent_status"`
}

// TrustBundleSyncResponse defines model for TrustBundleSyncResponse.
type TrustBundleSyncResponse map[string]TrustBundleSyncResponseItem

// TrustBundleSyncResponseItem defines model for TrustBundleSyncResponseItem.
type TrustBundleSyncResponseItem struct {
	// Digest base64 encoded SHA-256 digest of the bundle
	Digest externalRef0.BundleDigest `json:"digest"`

	// Signature base64 encoded signature of the bundle
	Signature externalRef0.Signature `json:"signature"`

	// SigningCertificate X.509 certificate in PEM format
	SigningCertificate externalRef0.Certificate `json:"signing_certificate"`

	// TrustBundle SPIFFE Trust bundle in JSON format
	TrustBundle externalRef0.TrustBundle `json:"trust_bundle"`
}

// Default defines model for Default.
type Default = externalRef0.ApiError

// OnboardParams defines parameters for Onboard.
type OnboardParams struct {
	// JoinToken Join token to be used for onboarding
	JoinToken string `form:"joinToken" json:"joinToken"`
}

// GetRelationshipsParams defines parameters for GetRelationships.
type GetRelationshipsParams struct {
	ConsentStatus *externalRef0.ConsentStatus `form:"consentStatus,omitempty" json:"consentStatus,omitempty"`
}

// BundlePutJSONRequestBody defines body for BundlePut for application/json ContentType.
type BundlePutJSONRequestBody = BundlePutRequest

// BundleSyncJSONRequestBody defines body for BundleSync for application/json ContentType.
type BundleSyncJSONRequestBody = BundleSyncPostRequest

// PatchRelationshipJSONRequestBody defines body for PatchRelationship for application/json ContentType.
type PatchRelationshipJSONRequestBody = RelationshipPatchRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BundlePut request with any body
	BundlePutWithBody(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BundlePut(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundlePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BundleSync request with any body
	BundleSyncWithBody(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BundleSync(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundleSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNewJWTToken request
	GetNewJWTToken(ctx context.Context, trustDomainName externalRef0.TrustDomainName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Onboard request
	Onboard(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *OnboardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRelationships request
	GetRelationships(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRelationship request with any body
	PatchRelationshipWithBody(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRelationship(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, body PatchRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BundlePutWithBody(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBundlePutRequestWithBody(c.Server, trustDomainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BundlePut(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundlePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBundlePutRequest(c.Server, trustDomainName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BundleSyncWithBody(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBundleSyncRequestWithBody(c.Server, trustDomainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BundleSync(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundleSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBundleSyncRequest(c.Server, trustDomainName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNewJWTToken(ctx context.Context, trustDomainName externalRef0.TrustDomainName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNewJWTTokenRequest(c.Server, trustDomainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Onboard(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *OnboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOnboardRequest(c.Server, trustDomainName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRelationships(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRelationshipsRequest(c.Server, trustDomainName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRelationshipWithBody(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRelationshipRequestWithBody(c.Server, trustDomainName, relationshipID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRelationship(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, body PatchRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRelationshipRequest(c.Server, trustDomainName, relationshipID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBundlePutRequest calls the generic BundlePut builder with application/json body
func NewBundlePutRequest(server string, trustDomainName externalRef0.TrustDomainName, body BundlePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBundlePutRequestWithBody(server, trustDomainName, "application/json", bodyReader)
}

// NewBundlePutRequestWithBody generates requests for BundlePut with any type of body
func NewBundlePutRequestWithBody(server string, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, trustDomainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trust-domain/%s/bundles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBundleSyncRequest calls the generic BundleSync builder with application/json body
func NewBundleSyncRequest(server string, trustDomainName externalRef0.TrustDomainName, body BundleSyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBundleSyncRequestWithBody(server, trustDomainName, "application/json", bodyReader)
}

// NewBundleSyncRequestWithBody generates requests for BundleSync with any type of body
func NewBundleSyncRequestWithBody(server string, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, trustDomainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trust-domain/%s/bundles/sync", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNewJWTTokenRequest generates requests for GetNewJWTToken
func NewGetNewJWTTokenRequest(server string, trustDomainName externalRef0.TrustDomainName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, trustDomainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trust-domain/%s/jwt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOnboardRequest generates requests for Onboard
func NewOnboardRequest(server string, trustDomainName externalRef0.TrustDomainName, params *OnboardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, trustDomainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trust-domain/%s/onboard", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "joinToken", runtime.ParamLocationQuery, params.JoinToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRelationshipsRequest generates requests for GetRelationships
func NewGetRelationshipsRequest(server string, trustDomainName externalRef0.TrustDomainName, params *GetRelationshipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, trustDomainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trust-domain/%s/relationships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ConsentStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consentStatus", runtime.ParamLocationQuery, *params.ConsentStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRelationshipRequest calls the generic PatchRelationship builder with application/json body
func NewPatchRelationshipRequest(server string, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, body PatchRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRelationshipRequestWithBody(server, trustDomainName, relationshipID, "application/json", bodyReader)
}

// NewPatchRelationshipRequestWithBody generates requests for PatchRelationship with any type of body
func NewPatchRelationshipRequestWithBody(server string, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, trustDomainName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "relationshipID", runtime.ParamLocationPath, relationshipID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trust-domain/%s/relationships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BundlePut request with any body
	BundlePutWithBodyWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BundlePutResponse, error)

	BundlePutWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundlePutJSONRequestBody, reqEditors ...RequestEditorFn) (*BundlePutResponse, error)

	// BundleSync request with any body
	BundleSyncWithBodyWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BundleSyncResponse, error)

	BundleSyncWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundleSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*BundleSyncResponse, error)

	// GetNewJWTToken request
	GetNewJWTTokenWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, reqEditors ...RequestEditorFn) (*GetNewJWTTokenResponse, error)

	// Onboard request
	OnboardWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *OnboardParams, reqEditors ...RequestEditorFn) (*OnboardResponse, error)

	// GetRelationships request
	GetRelationshipsWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*GetRelationshipsResponse, error)

	// PatchRelationship request with any body
	PatchRelationshipWithBodyWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRelationshipResponse, error)

	PatchRelationshipWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, body PatchRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRelationshipResponse, error)
}

type BundlePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *externalRef0.ApiError
}

// Status returns HTTPResponse.Status
func (r BundlePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundlePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleSyncPostResponse
	JSONDefault  *externalRef0.ApiError
}

// Status returns HTTPResponse.Status
func (r BundleSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNewJWTTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JwtGetResponse
	JSONDefault  *externalRef0.ApiError
}

// Status returns HTTPResponse.Status
func (r GetNewJWTTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNewJWTTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OnboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HarvesterOnboardResponse
	JSONDefault  *externalRef0.ApiError
}

// Status returns HTTPResponse.Status
func (r OnboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OnboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRelationshipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelationshipGetResponse
	JSONDefault  *externalRef0.ApiError
}

// Status returns HTTPResponse.Status
func (r GetRelationshipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRelationshipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *externalRef0.Relationship
	JSONDefault  *externalRef0.ApiError
}

// Status returns HTTPResponse.Status
func (r PatchRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BundlePutWithBodyWithResponse request with arbitrary body returning *BundlePutResponse
func (c *ClientWithResponses) BundlePutWithBodyWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BundlePutResponse, error) {
	rsp, err := c.BundlePutWithBody(ctx, trustDomainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBundlePutResponse(rsp)
}

func (c *ClientWithResponses) BundlePutWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundlePutJSONRequestBody, reqEditors ...RequestEditorFn) (*BundlePutResponse, error) {
	rsp, err := c.BundlePut(ctx, trustDomainName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBundlePutResponse(rsp)
}

// BundleSyncWithBodyWithResponse request with arbitrary body returning *BundleSyncResponse
func (c *ClientWithResponses) BundleSyncWithBodyWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BundleSyncResponse, error) {
	rsp, err := c.BundleSyncWithBody(ctx, trustDomainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBundleSyncResponse(rsp)
}

func (c *ClientWithResponses) BundleSyncWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, body BundleSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*BundleSyncResponse, error) {
	rsp, err := c.BundleSync(ctx, trustDomainName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBundleSyncResponse(rsp)
}

// GetNewJWTTokenWithResponse request returning *GetNewJWTTokenResponse
func (c *ClientWithResponses) GetNewJWTTokenWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, reqEditors ...RequestEditorFn) (*GetNewJWTTokenResponse, error) {
	rsp, err := c.GetNewJWTToken(ctx, trustDomainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNewJWTTokenResponse(rsp)
}

// OnboardWithResponse request returning *OnboardResponse
func (c *ClientWithResponses) OnboardWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *OnboardParams, reqEditors ...RequestEditorFn) (*OnboardResponse, error) {
	rsp, err := c.Onboard(ctx, trustDomainName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOnboardResponse(rsp)
}

// GetRelationshipsWithResponse request returning *GetRelationshipsResponse
func (c *ClientWithResponses) GetRelationshipsWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*GetRelationshipsResponse, error) {
	rsp, err := c.GetRelationships(ctx, trustDomainName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRelationshipsResponse(rsp)
}

// PatchRelationshipWithBodyWithResponse request with arbitrary body returning *PatchRelationshipResponse
func (c *ClientWithResponses) PatchRelationshipWithBodyWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRelationshipResponse, error) {
	rsp, err := c.PatchRelationshipWithBody(ctx, trustDomainName, relationshipID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRelationshipResponse(rsp)
}

func (c *ClientWithResponses) PatchRelationshipWithResponse(ctx context.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID, body PatchRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRelationshipResponse, error) {
	rsp, err := c.PatchRelationship(ctx, trustDomainName, relationshipID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRelationshipResponse(rsp)
}

// ParseBundlePutResponse parses an HTTP response from a BundlePutWithResponse call
func ParseBundlePutResponse(rsp *http.Response) (*BundlePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BundlePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBundleSyncResponse parses an HTTP response from a BundleSyncWithResponse call
func ParseBundleSyncResponse(rsp *http.Response) (*BundleSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BundleSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleSyncPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNewJWTTokenResponse parses an HTTP response from a GetNewJWTTokenWithResponse call
func ParseGetNewJWTTokenResponse(rsp *http.Response) (*GetNewJWTTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNewJWTTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JwtGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOnboardResponse parses an HTTP response from a OnboardWithResponse call
func ParseOnboardResponse(rsp *http.Response) (*OnboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OnboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HarvesterOnboardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRelationshipsResponse parses an HTTP response from a GetRelationshipsWithResponse call
func ParseGetRelationshipsResponse(rsp *http.Response) (*GetRelationshipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRelationshipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelationshipGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePatchRelationshipResponse parses an HTTP response from a PatchRelationshipWithResponse call
func ParsePatchRelationshipResponse(rsp *http.Response) (*PatchRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.Relationship
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload a new trust bundle to the server
	// (PUT /trust-domain/{trustDomainName}/bundles)
	BundlePut(ctx echo.Context, trustDomainName externalRef0.TrustDomainName) error
	// Synchronizes federated bundles with Galadriel Server
	// (POST /trust-domain/{trustDomainName}/bundles/sync)
	BundleSync(ctx echo.Context, trustDomainName externalRef0.TrustDomainName) error
	// Get a renewed JWT token with the same claims as the original one
	// (GET /trust-domain/{trustDomainName}/jwt)
	GetNewJWTToken(ctx echo.Context, trustDomainName externalRef0.TrustDomainName) error
	// Onboarding a new Trust Domain in the Galadriel Server
	// (GET /trust-domain/{trustDomainName}/onboard)
	Onboard(ctx echo.Context, trustDomainName externalRef0.TrustDomainName, params OnboardParams) error
	// List the relationships.
	// (GET /trust-domain/{trustDomainName}/relationships)
	GetRelationships(ctx echo.Context, trustDomainName externalRef0.TrustDomainName, params GetRelationshipsParams) error
	// Accept/Denies relationship requests
	// (PATCH /trust-domain/{trustDomainName}/relationships/{relationshipID})
	PatchRelationship(ctx echo.Context, trustDomainName externalRef0.TrustDomainName, relationshipID externalRef0.UUID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// BundlePut converts echo context to params.
func (w *ServerInterfaceWrapper) BundlePut(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "trustDomainName" -------------
	var trustDomainName externalRef0.TrustDomainName

	err = runtime.BindStyledParameterWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, ctx.Param("trustDomainName"), &trustDomainName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trustDomainName: %s", err))
	}

	ctx.Set(Harvester_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundlePut(ctx, trustDomainName)
	return err
}

// BundleSync converts echo context to params.
func (w *ServerInterfaceWrapper) BundleSync(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "trustDomainName" -------------
	var trustDomainName externalRef0.TrustDomainName

	err = runtime.BindStyledParameterWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, ctx.Param("trustDomainName"), &trustDomainName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trustDomainName: %s", err))
	}

	ctx.Set(Harvester_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleSync(ctx, trustDomainName)
	return err
}

// GetNewJWTToken converts echo context to params.
func (w *ServerInterfaceWrapper) GetNewJWTToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "trustDomainName" -------------
	var trustDomainName externalRef0.TrustDomainName

	err = runtime.BindStyledParameterWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, ctx.Param("trustDomainName"), &trustDomainName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trustDomainName: %s", err))
	}

	ctx.Set(Harvester_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetNewJWTToken(ctx, trustDomainName)
	return err
}

// Onboard converts echo context to params.
func (w *ServerInterfaceWrapper) Onboard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "trustDomainName" -------------
	var trustDomainName externalRef0.TrustDomainName

	err = runtime.BindStyledParameterWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, ctx.Param("trustDomainName"), &trustDomainName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trustDomainName: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OnboardParams
	// ------------- Required query parameter "joinToken" -------------

	err = runtime.BindQueryParameter("form", true, true, "joinToken", ctx.QueryParams(), &params.JoinToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter joinToken: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Onboard(ctx, trustDomainName, params)
	return err
}

// GetRelationships converts echo context to params.
func (w *ServerInterfaceWrapper) GetRelationships(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "trustDomainName" -------------
	var trustDomainName externalRef0.TrustDomainName

	err = runtime.BindStyledParameterWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, ctx.Param("trustDomainName"), &trustDomainName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trustDomainName: %s", err))
	}

	ctx.Set(Harvester_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRelationshipsParams
	// ------------- Optional query parameter "consentStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "consentStatus", ctx.QueryParams(), &params.ConsentStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consentStatus: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRelationships(ctx, trustDomainName, params)
	return err
}

// PatchRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) PatchRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "trustDomainName" -------------
	var trustDomainName externalRef0.TrustDomainName

	err = runtime.BindStyledParameterWithLocation("simple", false, "trustDomainName", runtime.ParamLocationPath, ctx.Param("trustDomainName"), &trustDomainName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter trustDomainName: %s", err))
	}

	// ------------- Path parameter "relationshipID" -------------
	var relationshipID externalRef0.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "relationshipID", runtime.ParamLocationPath, ctx.Param("relationshipID"), &relationshipID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter relationshipID: %s", err))
	}

	ctx.Set(Harvester_authScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchRelationship(ctx, trustDomainName, relationshipID)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.PUT(baseURL+"/trust-domain/:trustDomainName/bundles", wrapper.BundlePut)
	router.POST(baseURL+"/trust-domain/:trustDomainName/bundles/sync", wrapper.BundleSync)
	router.GET(baseURL+"/trust-domain/:trustDomainName/jwt", wrapper.GetNewJWTToken)
	router.GET(baseURL+"/trust-domain/:trustDomainName/onboard", wrapper.Onboard)
	router.GET(baseURL+"/trust-domain/:trustDomainName/relationships", wrapper.GetRelationships)
	router.PATCH(baseURL+"/trust-domain/:trustDomainName/relationships/:relationshipID", wrapper.PatchRelationship)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../../../common/api/schemas.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
