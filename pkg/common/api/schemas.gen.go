// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for ConsentStatus.
const (
	Approved ConsentStatus = "approved"
	Denied   ConsentStatus = "denied"
	Pending  ConsentStatus = "pending"
)

// ApiError defines model for ApiError.
type ApiError struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
}

// BundleDigest base64 encoded SHA-256 digest of the bundle
type BundleDigest = string

// Certificate X.509 certificate in PEM format
type Certificate = string

// ConsentStatus defines model for ConsentStatus.
type ConsentStatus string

// Date defines model for Date.
type Date = openapi_types.Date

// DeleteResponse defines model for DeleteResponse.
type DeleteResponse struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
}

// JWT defines model for JWT.
type JWT = string

// JoinToken defines model for JoinToken.
type JoinToken = UUID

// PageNumber The number of items to skip before starting to collect the result set.
type PageNumber = int

// PageSize The numbers of items to return.
type PageSize = int

// Relationship defines model for Relationship.
type Relationship struct {
	CreatedAt           time.Time        `json:"created_at"`
	Id                  UUID             `json:"id"`
	TrustDomainAConsent ConsentStatus    `json:"trust_domain_a_consent"`
	TrustDomainAId      UUID             `json:"trust_domain_a_id"`
	TrustDomainAName    *TrustDomainName `json:"trust_domain_a_name,omitempty"`
	TrustDomainBConsent ConsentStatus    `json:"trust_domain_b_consent"`
	TrustDomainBId      UUID             `json:"trust_domain_b_id"`
	TrustDomainBName    *TrustDomainName `json:"trust_domain_b_name,omitempty"`
	UpdatedAt           time.Time        `json:"updated_at"`
}

// SPIFFEID defines model for SPIFFEID.
type SPIFFEID = string

// Signature base64 encoded signature of the bundle
type Signature = string

// TrustBundle SPIFFE Trust bundle in JSON format
type TrustBundle = string

// TrustDomain defines model for TrustDomain.
type TrustDomain struct {
	CreatedAt         time.Time       `json:"created_at"`
	Description       *string         `json:"description,omitempty"`
	HarvesterSpiffeId *SPIFFEID       `json:"harvester_spiffe_id,omitempty"`
	Id                UUID            `json:"id"`
	Name              TrustDomainName `json:"name"`

	// OnboardingBundle SPIFFE Trust bundle in JSON format
	OnboardingBundle *TrustBundle `json:"onboarding_bundle,omitempty"`
	UpdatedAt        time.Time    `json:"updated_at"`
}

// TrustDomainName defines model for TrustDomainName.
type TrustDomainName = string

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"IwAA//8umwBrlB0AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
