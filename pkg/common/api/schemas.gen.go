// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for ConsentStatus.
const (
	Approved ConsentStatus = "approved"
	Denied   ConsentStatus = "denied"
	Pending  ConsentStatus = "pending"
)

// ApiError defines model for ApiError.
type ApiError struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
}

// BundleDigest base64 encoded SHA-256 digest of the bundle
type BundleDigest = string

// CertificateChain X.509 certificate chain in PEM format
type CertificateChain = string

// ConsentStatus defines model for ConsentStatus.
type ConsentStatus string

// Date defines model for Date.
type Date = openapi_types.Date

// JWT defines model for JWT.
type JWT = string

// JoinToken defines model for JoinToken.
type JoinToken = UUID

// PageNumber The number of items to skip before starting to collect the result set.
type PageNumber = int

// PageSize The numbers of items to return.
type PageSize = int

// Relationship defines model for Relationship.
type Relationship struct {
	CreatedAt           time.Time        `json:"created_at"`
	Id                  UUID             `json:"id"`
	TrustDomainAConsent ConsentStatus    `json:"trust_domain_a_consent"`
	TrustDomainAId      UUID             `json:"trust_domain_a_id"`
	TrustDomainAName    *TrustDomainName `json:"trust_domain_a_name,omitempty"`
	TrustDomainBConsent ConsentStatus    `json:"trust_domain_b_consent"`
	TrustDomainBId      UUID             `json:"trust_domain_b_id"`
	TrustDomainBName    *TrustDomainName `json:"trust_domain_b_name,omitempty"`
	UpdatedAt           time.Time        `json:"updated_at"`
}

// SPIFFEID defines model for SPIFFEID.
type SPIFFEID = string

// Signature base64 encoded signature of the bundle
type Signature = string

// TrustBundle SPIFFE Trust bundle in JSON format
type TrustBundle = string

// TrustDomain defines model for TrustDomain.
type TrustDomain struct {
	CreatedAt         time.Time       `json:"created_at"`
	Description       *string         `json:"description,omitempty"`
	HarvesterSpiffeId *SPIFFEID       `json:"harvester_spiffe_id,omitempty"`
	Id                UUID            `json:"id"`
	Name              TrustDomainName `json:"name"`

	// OnboardingBundle SPIFFE Trust bundle in JSON format
	OnboardingBundle *TrustBundle `json:"onboarding_bundle,omitempty"`
	UpdatedAt        time.Time    `json:"updated_at"`
}

// TrustDomainName defines model for TrustDomainName.
type TrustDomainName = string

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RZ6ZLbOJJ+FQV3fsy0qixeOlgRHRPgIYmUeEikLja9FTzASxRI8ZToqHffoOS2q+zy",
	"uMexG7vrP4YSiQ+ZROLLTNQnzE1PWYogKgvs6RNWuCE82bchyCIhz9O8G9ueF5VRiuxEy9MM5mUEC+zJ",
	"t5MCPmDZK1GH58Hufz/NT3aJPWERKkc09oCd7Et0qk7Y05BhHrBThO6/CBx/wMprBu+qMIA59vKAnWBR",
	"2MENCV7sU5Z086DnQLsqI79KerCzrfen2sPX/Yoyj1Bw33AJUVCG2BP5apPP8y8vD1gOz1WUQw97+uNu",
	"99d9P37RT50YumVnE1shL4F8FMCi7AzzYOHmUdZ9GOwJc+wCjugeRB2S19Pn4JEcjnreTb2X+r0yhD3n",
	"BoE9vHLKx+nhyBvb0MMnEzhmCEiPCNylXNL2RpTtQ3oESTgej5nJxPcclyHHuE8MocuMCcKhSew7zx4w",
	"rjsPP3LtEnKhHaHvrd1/GOJMz/2q13M7xV6Eepog9z5/zdd2Pnb/WGEmKj1OWBviVOSAIdykFpJFkZ+1",
	"HAcCNQCNyIJAFI16Wg+FKXes3YZfHaRFaoph7SpgJSzZFWhmsXCQ2cMMEBvBQuAia/ZuiJt7qTR36+yw",
	"XyfLnRLKLL3nDbGV+cNV5sVGjsFFSdJOhsv84aIad5mFlCRt5rxgy2xwwwQXef0e4tIQmyAQIhngM04/",
	"z3TRofiVwFoIrDYA0CLLN6DTWIBUZMGKO+OcAozGJ7jy4Gzo7WSWtbCvHJ34unNpA8m1uNyr/om0ELmY",
	"8nPxuA3TerBcLFk/wZ15IAZeP6SPk1O7YpX+eEIPr0V+OgZDSRr48Ri4iIhWG4Ofny2UTBlqdC2rWqh9",
	"M+hrtawtvHapHlbBtBpVLNeKfV0ebfqxNtgFC3Fw4Me7Y7BtxXU0iuqDhTY5vdSqui83q/bsGm2blK6n",
	"6WOTjpbLbTtm5q6GaLyZ1vPVQNXXiZ5KscPWl31zJA7x0kJ7JDKKABup8t2+TWnIvzoV49pzgR4MTc0W",
	"GX5vDqMCyTvUj1VbmXFQmgjLCS2I/FxkLNQoE3fXx3cnKMQo1IOIOq0Zij3X6LTPw3xaRyF1SLVwLqkX",
	"EMgsALP40LKhDOju7DwL8Y3ADpqV0EUTGwONDZTtfC2zwJ8IrAF4sJoPZBa/afPBasey+mSZ8rCcB409",
	"3ZwsFC6UjXjYXRDyr6MY+DcEXRZmPNgFrCE2zYKEC1/nJUclqBWsM6Mw8XRntEBhg+PZQuExmjENzoJV",
	"MQVA5cBKAIa+yHd6YB4HlFOppUYl/fmw9olhMlsMjsO2CbR4vjHkenSgLGSEzPRilKRJCpIEcTUcIUI/",
	"VGpMVIQeKbA2phNPVMUiWGZOSJjicpnyi4uyWKguanaxhaIjI0/lfDGiJ42qOLapDjZGmsbJBkxHPDuc",
	"E/x4Q0s7T+17cu2Y4nArjpf6nIqVCacUpIUq2gO4PT/Dab53yLBKeM0zY9cTL4a8DuhoIHj5eN26ppH3",
	"z/LAA4ddzFeIH/XZYt16iYU4e0uRq+oq75sp3j+wk4M80YA+BfNZFK2PK0JcB3OFlSakQwYyZMWy3SXu",
	"bJKzhXq4bA0LkR6Fn8pE2irKeEqehzpREDt1to3FvHTUEzKc61CQ1ucK/P67hW6kIij8O0TzUxYSDI4D",
	"/ukLCwmnlFwffPpKbd5lISEWVp+j7s5Cc/fE1B5HxAcDwGmDX+UWkHIM7uxjmHYnU3hAysbxi0xm00sX",
	"VxbqoowFssGTSeXNtldntz3auylu6h0ixwFd/NYOll0BPggEDfAc17FQygWBwAKZcJoRx8uSKa70y2Yb",
	"FZO5OO1XXO2WjDp0JduZ2xTBL8XjwNcOm1SVA5VsLOTMMoOj/ZMk2cO23AxWg/BSJqEmtgtxWeDEWai2",
	"iWineV9ZCNqhJqi9J2l0eG20MzMWMwvJl2NF+ZcxUoEG0nZUtNx1UO+PdXhh2nGuTYQd7ms6f4jVRt4I",
	"1cwTUHY+G7wXLDUu0i0kb4qImAYaLS4DKPOeny2vg5VmZ5vjQuVjLTgeqhBd29xQt0OKATbNUsWeg7nB",
	"t9sl41vI2EiXBPInIPk0yTh1bOg7M+TcurxWh8oHUsKK0dicsUw6C5Zphosih1eTBVFuyV3Yry3EzEiV",
	"WPDRmpF9XRVdjRH1Zjc+HQ5TP5nJHGgEAGwllmdCwwcHfrvGtY5XWLDiQSDMLCSDyY1hhDsbTWVwY6Bm",
	"vrppqyx7EKZyzIPcpDNGlJNivPfYUT9RL0gPTc1CMntHEJvVQWZtMOWMaWYy66rJ6EWIQuIg75t9u4gj",
	"ov42I3HNBlioy0hgxc1TAJebybWlxHJxweeaKAiaMxsN6CtDj0UtOl4C6ijtlsZ0ES40IqHIjJHF/clC",
	"tVTTs/Wqsnfq1UhMH6LLdj6hjmeGh8x+chTbYpKvp+vhqdZ2Hlem+i4Ur9vFTDGLSRGIFprhM20ZG/lE",
	"3537TuUIVSmOSt/h2eMijrNlUm/Hun0eOwRFrMAwhFKlLnb9YhbRFAWmKwuZ8xOTJ0t157cuOZnYU9WJ",
	"5pytJnGwM4tDoO+Tidb3E0eWpgOPumyBT5rkWlAD1R8mTGChzAui3TSHrlJEMpvzZyI+JhAIswFT0tv5",
	"jAelPGGUTdqoDjnamGm5MFhTbFO5McdprluI8FT8tJwPlHxZTykcXeNApqNVOO4r6r9kndf1ZQZP75Zc",
	"KSogKvXSLqtbIQxRV97+gdlZlqc19LAHzIMoug0yiLxu3cd3gHi7/KbsJXGSeMSJRwp/bYfX6b2tcol3",
	"4KSd8RYNXqXQmbmRGkniphUJJRILEa2HLieOxGO233IS8wFepdbbiZEaiRc5lnHFOFAqf2zEqImc07Q0",
	"9Ztybc/oYD1jkk7esZwYpxfFEEg5locyL1791QfdTxaXZi3pMlwspuTKoP0mk6HkUyNNPY6u0vbZ9lZF",
	"0Qzd1+7FTfnWOxpnRg9YZpclzLsK9j//sB9b8Gjij4xlPT5/7P/Tsj68J/v7t8J//PNv752glEbISI8Q",
	"vf1elG9Phv6IfhyOifEjPRyRjw7lu4+ky4wofzSyfXv02vCqiry3llPf2I0/Mvaj//HT5OXxy5j+C2OC",
	"fHnXcM0OoFKdHJh/X+cbIeyh21zXgkQlPBW9Mu0VxyjrOdBPc9grSjsvIxR0cjdNEuiWt14lh0WVlL0C",
	"lh+wVw3bu+1aZ4IetfBugG9XSdl1XQ8/tKZ4Y04OyypHH950ifjrJvG9PdcwsTvcIoyyf7dJzaFdQu/Z",
	"Ln900wx88kThTzhufnvnHsvo9FcuXuR12H/LoY89Yf8x+NpnDz432YPNRuQ7zTKvivLZS092hJ7tZ/fO",
	"JD9b/ZZwvof55f2RfYI/W2p0S/jbCqVT/xbF+e/xwvlVL5xf9aLKvP/hyPjm3eFGFq/i8Y0J7x3qe5/o",
	"hzH0w2N5731D18TpVBD5t54XWeT78GkweI00aNL8mKS29xx5EJWRH8H8548w9OSde6JHAbLLKoc/fVIp",
	"/tT8F68p9mxk7inb9PujMhhc17zprXWllCkmac2dcjX3a8nkCemwI4wvvzkz9vbS1dwN8e0sKc2tgh92",
	"RKMZAqG0wlU2No1qbE7mPmzsvZTcdAz8ovIBqRguIfNHQkJS6JzWtWPgVznuGobN7+9x9S3k7g9J3/t7",
	"P4DeTeezc70I9SRdVd57kflkdVny2a7KMM2jjtss7OmPTxYGL1mUw+LZLi3sycKI0YQeEiOKpizswcKO",
	"8PocebcZ4Bmmi7vjtmBG7iioVxeJHa08YcRf9Urx65t+VjlJ5D4f4fW2Rp4eG6E5zLsGpo1xDqwO4ucx",
	"D1YuvwqAcCE0c934AsWbhXomZRZXh9rOd4o2t7OZ4p+GwnRApM1+iEReOcVG5AyUqz/mIFfrS1dwKfyQ",
	"2U4NnGA5n7gFGfIt0bWG2MvDj/ybEN/75wdbm3dtAxzs9jgjdz5D7crZ5bT29j7AFfZX/ct5PY7cHJ31",
	"DRLIKySktPJZfrZ0SlGOpel2toBztVwYw+qcsIOFMVFIargvin1gLFdrOWwzwLuyTG8Gh8St0+txPjwF",
	"N/8+PlhYDv0cFuFzGKG7h/jN0AKeK4hc+HxPobeZ8W3m9dW8iUuPsLCXHwbgnfP+DybNN/fh9Sb3O3H3",
	"sFeGdtnLYZbDjstuVNCRUHnt7f/SS/CrYuzvvd/+uNeG9mP7sffbP357t8QK7byGRQnz5zsd/oW89IVN",
	"/61a4BfTVoqc1M67nuLZ+UIuP8X4zEP/a2nv5uyPs997Oepb399Ye7sGH+5B8sFNT7+YkW5n8f+qB3h5",
	"wAroVnlUXvXugO8X9mvQdimikzjQzmE+/dPMrjd8uP/Np0O7z35FD8syw1468Aj5KfaEqiR5wNIMIjuL",
	"sCcMu7kUFveZl/8KAAD//8GaGKdMGgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
