// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for ConsentStatus.
const (
	Accepted ConsentStatus = "accepted"
	Disabled ConsentStatus = "disabled"
	Pending  ConsentStatus = "pending"
)

// ApiError defines model for ApiError.
type ApiError struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
}

// BundleDigest base64 encoded SHA-256 digest of the bundle
type BundleDigest = string

// Certificate X.509 certificate in PEM format
type Certificate = string

// ConsentStatus defines model for ConsentStatus.
type ConsentStatus string

// JWT defines model for JWT.
type JWT = string

// JoinToken defines model for JoinToken.
type JoinToken = UUID

// Relationship defines model for Relationship.
type Relationship struct {
	CreatedAt           time.Time     `json:"created_at"`
	Id                  UUID          `json:"id"`
	TrustDomainAConsent ConsentStatus `json:"trust_domain_a_consent"`
	TrustDomainAId      UUID          `json:"trust_domain_a_id"`
	TrustDomainBConsent ConsentStatus `json:"trust_domain_b_consent"`
	TrustDomainBId      UUID          `json:"trust_domain_b_id"`
	UpdatedAt           time.Time     `json:"updated_at"`
}

// SPIFFEID defines model for SPIFFEID.
type SPIFFEID = string

// Signature defines model for Signature.
type Signature = string

// TrustBundle X.509 certificate in PEM format
type TrustBundle = Certificate

// TrustDomain defines model for TrustDomain.
type TrustDomain struct {
	CreatedAt         time.Time       `json:"created_at"`
	Description       *string         `json:"description,omitempty"`
	HarvesterSpiffeId *SPIFFEID       `json:"harvester_spiffe_id,omitempty"`
	Id                UUID            `json:"id"`
	Name              TrustDomainName `json:"name"`

	// OnboardingBundle X.509 certificate in PEM format
	OnboardingBundle *TrustBundle `json:"onboarding_bundle,omitempty"`
	UpdatedAt        time.Time    `json:"updated_at"`
}

// TrustDomainName defines model for TrustDomainName.
type TrustDomainName = string

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
